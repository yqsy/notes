---
title: 现代操作系统
date: 2018-3-1 09:35:18
categories: [读书笔记]
---

<!-- TOC -->

- [1. 引论](#1-引论)
- [2. 进程间通信,同步](#2-进程间通信同步)
    - [2.1. 调度](#21-调度)
    - [2.2. 经典的IPC问题](#22-经典的ipc问题)

<!-- /TOC -->

<a id="markdown-1-引论" name="1-引论"></a>
# 1. 引论

流水线pipeline

更先进，超标量cpu

使用陷阱执行系统调用

cpu多线程，超线程是指允许cpu保持两个不同线程的状态，然后在纳秒时间尺度内切换。

io设备输入输出3种方式。

* 驱动程序过程调用。然后占用cpu时间忙等待得到结果
* 设备操作完成时使用特定的总线发送信号给中断控制器芯片(中断有级别)
* dma芯片


minix3微内核只有`3200行c语言代码`和800行用于非常低层功能的汇编语言代码，诸如捕捉中断，进程切换等。

c语言对写操作系统非常有吸引力，因为在系统层面。任意时刻启动垃圾回收功能是不可接受的。


`进程`是对于正在运行程序的一个`抽象`。

在某一瞬间，cpu只能运行一个进程，但在一秒钟没，它可能运行多个进程，`伪并行`。与之相对的是`多核心真正并行`。

采用`多道程序设计`可以提高cpu的利用率。 `宏观并行，微观串行。`


`线程` `共享同一个地址空间和所有可用数据`，更快，`使得顺序进程的思想得以保留下来`。

x|x
-|-
多线程。|并行性，阻塞系统调用。
有限状态机。|并行性，非阻塞系统调用。中断。

---

每个进程中的内容:
* 地址空间
* 全局变量
* 打开文件
* 子进程
* 即将发生的报警
* 信号与信号处理程序
* 账户信息

每个线程中的内容:
* 程序技术器
* 寄存器
* 堆栈
* 状态

---


<a id="markdown-2-进程间通信同步" name="2-进程间通信同步"></a>
# 2. 进程间通信,同步

进程间通信(IPC):  
https://en.wikipedia.org/wiki/Inter-process_communication

竞争条件:  
https://www.youtube.com/watch?v=3TJHdETtfhE


共享资源 -> 竞争条件(race condition) -> 临界区 -> 互斥方案 -> 生产者消费者问题 -> 信号量 -> 互斥量(简化,抛弃计数) -> 条件变量(允许线程由于一些未到达的条件而阻塞) -> 管程(语言级别支持)

忙等待的互斥

* 屏蔽中断 (单处理系统)
* 锁变量 (0 1 表示状态) 但是还是会产生竞争条件
* 严格轮换法
* Peterson解法 (忙等待)
* `TSL,XCHG 指令` (忙等待)  优先级反转
* 睡眠唤醒


补充一个原子的实现:

```
# CAS https://en.wikipedia.org/wiki/Compare-and-swap
get __sync_val_compare_and_swap(&value_, 0, 0); // 这里是原子得获取到值

# TSL
getAndSet __sync_lock_test_and_set

# fetch and add
getAndAdd __sync_fetch_and_add

```

反编译
```
    int32_t val = 1;
    __sync_val_compare_and_swap(&val, 2, 3);

   0x000000000041a2f3 <+4>:     movl   $0x1,-0x4(%rbp)
   0x000000000041a2fa <+11>:    mov    $0x2,%eax
   0x000000000041a2ff <+16>:    mov    $0x3,%edx
   0x000000000041a304 <+21>:    lock cmpxchg %edx,-0x4(%rbp)
```

TSL(Test and set lock):  
将一个内存字lock读到寄存器RX中,然后在内存地址上存一个非零值.读和写字操作是不可分割的.即该指令结束之前其他处理器均不允许访问该内存字.`执行TSL指令的CPU将锁住内存总线,以禁止其他CPU在本指令结束之前访问内存`

https://www.youtube.com/watch?v=3TJHdETtfhE

```
enter_region:
    TSL REGISTER,LOCK // 复制锁到寄存器并将锁设置为1
    CMP REGISTER,#0   // 锁是0吗
    JNE enter-region  // 若不是0,说明锁已经被设置,所以循环
    RET               // 若是调用者,进入了临界区

leave_region:
    MOVE LOCK,#0      // 在锁中存入0
    RET               // 返回调用者
```


生产者消费者问题:  
当缓冲区已满,此时生产者还想向其中放入一个新的数据项,解决办法是让生产者睡眠,待消费者从缓冲区中取出一个或多个数据项时再唤醒它.

需要一个count变量表示唤醒次数,若值为0零时,进程睡眠,但是count会产生竞态条件

互斥量:

```
mutexlock:
    TSL REGISTER,MUTEX // 将互斥量信号复制到寄存器,并且将互斥量信号重置为1
    CMP REGISTER,#0    // 互斥量信号是0吗
    JZE ok             // 是0,返回
    CALL thread_yield  // 互斥信号量很忙,调度另一个线程
    JMP mutex_lock     // 稍后再试
ok: RET                // 返回调用者,进入临界区

mutex_unlock:
    MOVE MUTEX,#0      // 将mutex置为0
    RET                // 返回调用者
```

enter_region和mutexlock的`区别`所在就是后者在取锁失败时,调用`thread_yield`将CPU放弃给另一个线程.

在mutexlock取锁失败时,调用thread_yield将CPU放弃给另一个线程,`解决忙等待`.并且是在用户态的,`不需要内核调用`.



<a id="markdown-21-调度" name="21-调度"></a>
## 2.1. 调度
* 批处理 (1.先来先服务 2.最短作业优先 3.最短剩余时间优先)
* 交互式 (1.轮转调度 2.优先级调度 3.多级队列 4.最短进程优先 5.保证调度 6.彩票调度 7.公平分享调度)
* 实时

<a id="markdown-22-经典的ipc问题" name="22-经典的ipc问题"></a>
## 2.2. 经典的IPC问题

* 哲学家就餐问题
* 读者-写者问题

