---
title: redis设计与实践
date: 2017-12-3 16:14:14
categories: [读书笔记]
---

<!-- TOC -->

- [1. p8-动态字符串](#1-p8-动态字符串)
    - [1.1. 定义](#11-定义)
    - [1.2. 总结](#12-总结)
    - [1.3. C字符串和SDS的相比](#13-c字符串和sds的相比)
- [2. p21-Redis链表](#2-p21-redis链表)
    - [2.1. 主要API](#21-主要api)
    - [2.2. 重点回顾](#22-重点回顾)
- [3. p23-字典](#3-p23-字典)
    - [3.1. 哈希表](#31-哈希表)
    - [3.2. 哈希表节点](#32-哈希表节点)
    - [3.3. Redis字典结构](#33-redis字典结构)
    - [3.4. Redis使用的hash算法](#34-redis使用的hash算法)
    - [3.5. 解决键冲突](#35-解决键冲突)
    - [3.6. 渐进式rehash](#36-渐进式rehash)
    - [3.7. 字典API](#37-字典api)
    - [3.8. 重点回顾](#38-重点回顾)
- [4. p45-跳跃表](#4-p45-跳跃表)
    - [4.1. API](#41-api)
    - [4.2. 重点回顾](#42-重点回顾)
- [5. p51-整数集合API](#5-p51-整数集合api)
    - [5.1. 重点回顾](#51-重点回顾)
- [6. p59-压缩列表](#6-p59-压缩列表)
    - [6.1. API](#61-api)
    - [6.2. 重点回顾](#62-重点回顾)
- [7. p60-对象](#7-p60-对象)
    - [7.1. 键和值都是对象](#71-键和值都是对象)
    - [7.2. 对象的类型](#72-对象的类型)
    - [7.3. 不同类型值对象的TYPE命令输出](#73-不同类型值对象的type命令输出)
    - [7.4. 重点回顾](#74-重点回顾)
- [8. p90-单机数据库的实现](#8-p90-单机数据库的实现)
    - [8.1. 切换数据库](#81-切换数据库)
- [9. p98-读写键空间时的维护操作](#9-p98-读写键空间时的维护操作)
- [10. p99-设置键的生存时间或过期时间](#10-p99-设置键的生存时间或过期时间)
    - [10.1. 设置过期时间](#101-设置过期时间)
    - [10.2. 保存过期时间](#102-保存过期时间)
    - [10.3. 过期间删除策略](#103-过期间删除策略)
    - [10.4. 定时删除和惰性删除的缺点](#104-定时删除和惰性删除的缺点)
    - [10.5. 定期删除](#105-定期删除)
- [11. p137-RDB持久化](#11-p137-rdb持久化)
    - [11.1. 重点回顾](#111-重点回顾)
- [12. p138-AOF持久化](#12-p138-aof持久化)
    - [12.1. 不同appendfsync值产生不同的持久化行为](#121-不同appendfsync值产生不同的持久化行为)
    - [12.2. AOF持久化的效率和安全性](#122-aof持久化的效率和安全性)
    - [12.3. 重点回顾](#123-重点回顾)
- [13. p161-时间驱动重点回顾](#13-p161-时间驱动重点回顾)
- [14. p218-主从同步重点回顾](#14-p218-主从同步重点回顾)
- [15. p288-集群重点回顾](#15-p288-集群重点回顾)
- [16. -redis的ACID](#16--redis的acid)
    - [16.1. 原子性(Atomicity)](#161-原子性atomicity)
    - [16.2. 一致性(Consistency)](#162-一致性consistency)
    - [16.3. 隔离性(Isolation)](#163-隔离性isolation)
    - [16.4. 持久性(Durability)](#164-持久性durability)
- [17. p385-慢查询日志重点回顾](#17-p385-慢查询日志重点回顾)

<!-- /TOC -->


<a id="markdown-1-p8-动态字符串" name="1-p8-动态字符串"></a>
# 1. p8-动态字符串
Redis 没有直接使用C 语言传统的字符串表示（以空字符结尾的字符数组，以下简称C
字符串）， **而是自己构建了一种名为简单动态字符串（simple dynamic string, SDS ) 的抽象
类型，并将SDS 用作Redis 的默认字符串表示。**


<a id="markdown-11-定义" name="11-定义"></a>
## 1.1. 定义

```
struct sdshdr {
  // 记录buf数组中已使用字节的数量
  // 记录SDS所保存字符串的长度
  int len;
  
  // 记录buf数组中未使用字节的数量
  int free;
  
  // 字节数组,用于保存字符串
  char buf[];
}
```

<a id="markdown-12-总结" name="12-总结"></a>
## 1.2. 总结

C字符串和SDS之间的区别

C|SDS
-|-
获取字符串长度的复杂度为O(N)|获取字符串长度的复杂度为O(1)
API 是不安全的，可能会造成缓冲区溢|API是安全的，不会造成缓冲区溢出
修改字符串长度N 次必然需要执行N 次内存重分配|修改字符串长度N 次最多需要执行N 次内存重分配
只能保存文本数据|可以保存文本或者二进制数据
可以使用所有<string.h>库中的函数|可以使用一部分<string.h>库中的函数


SDS的主要操作API

函数|作用|时间复杂度
-|-|-
sdsnew|创建一个包含给定C 字符串的SDS|O(N),N为给定C字符串的长度
sdsempty|创建一个不包含任何内容的空SDS|O(1)
sdsfree|释放给定的SDS|O(N),N为被释放SDS的长度
sdslen|返回SDS的已使用空间字节数|这个值可以通过读取SDS的len属性来直接获得,复杂度为O(1)
sdsavail|返回SDS 的未使用空间字节数|这个值可以通过读取SDS的free属性来直接获得,复杂度为O(1)
sdsdup|创建一个给定SDS 的副本(copy)|O(N),N为给定SDS的长度
sdsclear|清空SDS保存的字符串内容|因为惰性空间释放策略,复杂度为O(1)
sdscat|将给定C 字符串拼接到SDS 字符串的末尾|O(N),N为拼接C字符串的长度
sdscatsds|将给定SDS 字符串拼接到另一个SDS 字符串的末尾|O(N),N为被拼接SDS字符串的长度
sdscpy|将给定的C 字符串复制到SDS 里面，覆盖SDS 原有的字符串|O(N),N为被复制C字符串的长度
sdsgrowzero|用空字符将SDS扩展至给定长度|O(N),N为扩展新增的字节数
sdsrange|保留SDS 给定区间内的数据，不在区间内的数据会被覆盖或清除|O(N),N为被保留数据的字节数
sdstrim|接受一个SDS 和一个C 字符串作为参数，从SDS 中移除所有在C 字符串中出现过的字符|O(N2),N为给定C字符串的长度
sdscmp|对比两个SDS字符串是否相同|O(N),N为两个SDS中较短的那个SDS的长度

<a id="markdown-13-c字符串和sds的相比" name="13-c字符串和sds的相比"></a>
## 1.3. C字符串和SDS的相比

比起C字符串,SDS具有以下优点:

  * 常数复杂度获取字符串长度。
  * 杜绝缓冲区溢出。
  * 减少修改字符串长度时所需的内存重分配次数。
  * 二进制安全。
  * 兼容部分C 字符串函数。


<a id="markdown-2-p21-redis链表" name="2-p21-redis链表"></a>
# 2. p21-Redis链表

  * 双端: 链表节点带有prev和next指针,获取某个节点的前置节点和后置节点的复杂度都是O(1)
  * 无环:表头节点的prev指针和表尾节点的next指针都指向NULL,对链表的访问以NULL为终点
  * 带表头指针和表尾指针：通过list 结构的head 指针和tail 指针，程序获取链表的表头节点和表尾节点的复杂度为O (1)。
  * 带链表长度计数器：程序使用list 结构的len 属性来对list 持有的链表节点进行计数，程序获取链表中节点数量的复
杂度为O(1)。
  * 多态：链表节点使用void* 指针来保存节点值，并且可以通过list 结构的dup、free、match 三个属性为节点值设置类型特定函数，所以链表可以用于保存各种不同类型的值。


<a id="markdown-21-主要api" name="21-主要api"></a>
## 2.1. 主要API
函数|作用|时间复杂度
-|-|-
 listSetDupMethod    | 将给定的函数设置为链表的节点值复制函数                       | 复制函数可以通过链表的dup 属性直接获得，O(1)                      
 listGetDupMethod    | 返回链表当前正在使用的节点值复制函数                        | O(1)                                              
 listSetFreeMethod   | 将给定的函数设置为链表的节点值释放函数                       | 释放函数可以通过链表的free 属性直接获得,O(1)                     
 listGetFree         | 返回链表当前正在使用的节点值释放函数                        | O (1)                                             
 listSetMatchMethod  | 将给定的函数设置为链表的节点值对比函数                       | 对比函数可以通过链表的match 属性直接获得,O(1)                    
 listGetMatchMethod  | 返回链表当前正在使用的节点值对比函数                        | O(1)                                              
 listLength          | 返冋链表的长度（包含了多少个节点）                         | 返冋链表的长度（包含了多少个节点） 链表长度可以通过链表的len 属性直接获得，O(1)  
 listFirst           | 返回链表的表头节点                                 | 表头节点可以通过链表的head 属性直接获得， O(1)                    
 listLast            | 返回链表的表尾节点                                 | 表尾节点可以通过链表的tail 属性直接获得,O(1)                     
 listPrevNode        | 返回给定节点的前置节点                               | 前置节点可以通过节点的pirev 属性直接获得,O(1)                    
 listNextNode        | 返回给定节点的后置节点                               | 后置节点可以通过节点的next 属性直接获得,O(1)                     
 listNodeValue       | 返回给定节点目前正在保存的值                            | 节点值可以通过节点的value 属性直接获得， O(1)                    
 listCreate          | 创建一个不包含任何节点的新链表                           | O(1)                                              
 listAddNodeHead     | 将一个包含给定值的新节点添加到给定链表 的表头                 | O(1)                                              
 listAddNodeTail     | 将一个包含给定值的新节点添加到给定链表 的表尾                 | O(1)                                              
 listlnsertNode      | 将一个包含给定值的新节点添加到给定节点 的之前或者之后             | O(1)                                              
 listSearchKey       | 査找并返回链表中包含给定值的节点                          | O(N),N为链表长度                                       
 listlndex           | 返回链表在给定索引上的节点                             | O(N),N 为链表长度                                      
 listDelNode         | 从链表中删除给定节点                                | O(N), N 为链表长度                                     
 listRotate          | 将链表的表尾节点弹出，然后将被弹出的节 点插人到链表的表头，成为新的表头节点  | O(1)                                              
 listDup             | 复制一个给定链表的副本                               | O(N), N 为链表长度                                     
 listRelease         | 释放给定链表，以及链表中的所有节点                         | O(N),N为链表长度                                       

<a id="markdown-22-重点回顾" name="22-重点回顾"></a>
## 2.2. 重点回顾

  * 链表被广泛用于实现Redis 的各种功能，比如列表键、发布与订阅、慢査询、监视器等
  * 每个链表节点由一个listNode 结构来表示，每个节点都有一个指向前置节点和后置节点的指针，所以Redis 的链表实现是双端链表。
  * 每个链表使用一个list 结构来表示，这个结构带有表头节点指针、表尾节点指针，以及链表长度等信息。
  * 因为链表表头节点的前置节点和表尾节点的后置节点都指向NULL, 所以Redis 的链表实现是无环链表。
  * 通过为链表设置不同的类型特定函数，Redis 的链表可以用于保存各种不同类型的值。


<a id="markdown-3-p23-字典" name="3-p23-字典"></a>
# 3. p23-字典
字典，又称为符号表（symbol table )、关联数组（associative array) 或映射（map), 是
一种用于保存键值对（key-value pair ) 的抽象数据结构。

字典在Redis 中的应用相当广泛，比如Redis 的数据库就是使用字典来作为底层实现的，
**对数据库的增、删、査、改操作也是构建在对字典的操作之上的。**


<a id="markdown-31-哈希表" name="31-哈希表"></a>
## 3.1. 哈希表

```
typedef struct dictht {
    // 哈希表数组
    dictEntry **table;
    
    // 哈希表大小
    unsigned long size;
    
    // 哈希表大小掩码,用于计算索引值
    // 总是等于 size-1
    unsigned long sizemask;
    
    // 该哈希表已有节点的数量
    unsigned long used;
} dictht;
```

<a id="markdown-32-哈希表节点" name="32-哈希表节点"></a>
## 3.2. 哈希表节点
哈希表节点使用dictEntry结构表示,每个dictEntry结构都保存着一个键值对:

typedef struct dictEntry {
    
    // 键
    void *key;
    
    // 值
    union {
        void *val;
        uint64 tu64;
        int64 ts64;
    } v;
    
    // 指向下个哈希表节点,形成链表
    struct dictEntry *next;
} dictEntry;


next 属性是指向另一个哈希表节点的指针，这个指针可以将多个哈希值相同的键值对连接在一次，**以此来解决键冲突（collision) 的问题。
**

<a id="markdown-33-redis字典结构" name="33-redis字典结构"></a>
## 3.3. Redis字典结构
```
typedef struct dict {
    // 类型特定函数
    dictType *type;
    
    // 私有数据
    void *privdata;
    
    // 哈希表
    dictht ht[2];
    
    // rehash索引
    // 当rehash不在进行时,值为-1
    int trehashidx; 
} dict;
```


<a id="markdown-34-redis使用的hash算法" name="34-redis使用的hash算法"></a>
## 3.4. Redis使用的hash算法
Redis 使用MurmurHash2算法来计算键的哈希值
MurmurHash 算法最初由Austin Appleby 于2008 年发明，** 这种算法的优点在于，即使
输人的键是有规律的，算法仍能给出一个很好的随机分布性，并且算法的计算速度也非常快。**
MurmurHash 算法目前的最新版本为MurmurHash3 , 而Redis 使用的是MurmurHash2 , 关
于MumuirHash 算法的更多信息可以参考该算法的主页：http://code.google.eom/p/smhasher/。

<a id="markdown-35-解决键冲突" name="35-解决键冲突"></a>
## 3.5. 解决键冲突
当有两个或以上数量的键被分配到了哈希表数组的同一个索引上面时，我们称这些键发生了冲突（collision ).
Redis 的哈希表使用链地址法（separate chaining) 来解决键冲突，每**个哈希表节点都有
一个next 指针，多个哈希表节点可以用next 指针构成一个单向链表，被分配到同一个索
引上的多个节点可以用这个单向链表连接起来，这就解决了键冲突的问题。**


<a id="markdown-36-渐进式rehash" name="36-渐进式rehash"></a>
## 3.6. 渐进式rehash
因为在进行渐进式rehash的过程中，字典会同时使用ht[0]和ht[l]两个哈希表，
所以在渐进式rehash进行期间，字典的删除（delete)、查找（find)、更新（update)等操作
会在两个哈希表上进行。**例如，要在字典里面査找一个键的话，程序会先在ht[0]里面进
行查找，如果没找到的话，就会继续到ht[l]里面进行査找，诸如此类。**
另外，在渐进式rehash执行期间，新添加到字典的键值对一律会被保存到ht[l]里面，
而ht[0]则不再进行任何添加操作，这一措施保证了ht[0]包含的键值对数量会只减不
增，并随着rehash操作的执行而最终变成空表。


<a id="markdown-37-字典api" name="37-字典api"></a>
## 3.7. 字典API

函数|作用|实践复杂度
-|-|-
dictCreate|创建一个新的字典|O(1)
dictAdd|将给定的键值对添加到字典里面|O(1)
dictReplace|将给定的键值对添加到字典里面，如果键已经存在于字典，那么用新值取代原有的值|O(1)
dictFetchValue|返回给定键的值|O(1)
dictGetRandomKey|从字典中随机返回一个键值对|O(1)
dictDelete|从字典中删除给定键所对应的键值对|O(1)
dictRelease|释放给定字典,以及字典中包含的所有键值对|O(N),N为字典包含的键值对数量



<a id="markdown-38-重点回顾" name="38-重点回顾"></a>
## 3.8. 重点回顾
  * 字典被广泛用于实现Redis 的各种功能，其中包括数据库和哈希键。
  * Redis 中的字典使用哈希表作为底层实现，每个字典带有两个哈希表，一个平时使用，另一个仅在进行rehash 时使用。
  * 当字典被用作数据库的底层实现，或者哈希键的底层实现时， Redis 使用MurmurHash2算法来计算键的哈希值。
  * 哈希表使用链地址法来解决键冲突，被分配到同一个索引上的多个键值对会连接成一个单向链表
  * 在对哈希表进行扩展或者收缩操作时，程序需要将现有哈希表包含的所有键值对rehash 到新哈希表里面，并且这个rehash 过程并不是一次性地完成的，而是渐进式地完成的。


<a id="markdown-4-p45-跳跃表" name="4-p45-跳跃表"></a>
# 4. p45-跳跃表

reference: https://www.zhihu.com/question/20202931
(懵懂)

<a id="markdown-41-api" name="41-api"></a>
## 4.1. API

函数|作用|时间复杂度
-|-|-
 zslCreate              | 创建一个新的跳跃表                                                                             | O(1)                                  
 zslFree                | 释放给定跳跃表，以及表中包含的所有节点                                                                   | O(N),N为跳跃表的长度                         
 zsllnsert              | 将包含给定成员和分值的新节点添加到跳跃表中                                                                 | 平均O(logN),最坏O(N),N为跳跃表长度              
 zslDelete              | 删除跳跃表中包含给定成员和分值的节点                                                                    | 平均O(logN),最坏O(N),N为跳跃表长度              
 zslGetRank             | 返回包含给定成员和分值的节点在跳跃表中的排位                                                                | 平均O(logN),最坏O(N),N为跳跃表长度              
 zslGetElementByRank    | 返回跳跃表在给定排位上的节点                                                                        | 平均O(logN),最坏O(N),N为跳跃表长度              
 zslIsInRange           | 给定一个分值范围（ range ), 比如0 到15, 20 到28, 诸如此类，如果跳 跃表中有至少一个节点的分值在这个 范围之内，那么返回1，否则返回0  | 通过跳跃表的表头节点和表尾节点， 这个检测可以用0(1) 复杂度完成  
 zslFirstlnRange        | 给定一个分值范围，返回跳跃表中 第一个符合这个范围的节点                                                        | 平均O(logN),最坏O(N),N为跳跃表长度              
 zslLastlnRange         | 给定一个分值范围，返回跳跃表中 最后一个符合这个范围的节点                                                       | 平均O(logN),最坏O(N),N为跳跃表长度              
 zslDeleteRangeByScore  | 给定一个分值范围，删除跳跃表中 所有在这个范围之内的节点                                                        | O(N),N为被删除节点                          
 zslDeleteRangeByRank   | 给定一个排位范围，删除跳跃表中 所有在这个范围之内的节点                                                        | O(N),N为被删除节点                          


<a id="markdown-42-重点回顾" name="42-重点回顾"></a>
## 4.2. 重点回顾

  * 跳跃表是有序集合的底层实现之一。
  * Redis的表现实现由zskiplist 和zskiplistNode 两个结构组成，其中zskiplist用于保存跳跃表信息（比如表头节点、表尾节点、长度)， 而zskiplistNode 则用于表示跳跃表节点。
  * 每个跳跃表节点的层高都是1 至32 之间的随机数。
  * 在同一个跳跃表中，多个节点可以包含相同的分值，但每个节点的成员对象必须是唯一的。
  * 跳跃表中的节点按照分值大小进行排序，当分值相同时，节点按照成员对象的大小进行排序。



<a id="markdown-5-p51-整数集合api" name="5-p51-整数集合api"></a>
# 5. p51-整数集合API
函数|作用|时间复杂度
-|-|-
 intsetNew      | 创建一个新的压缩列表       | O(1)                                      
 intestAdd      | 将给定元素添加到整数集合里面   | O(N)                                      
 intsetRemove   | 将整数集合中移除给定元素     | O(N)                                      
 intsetFind     | 检査给定值是否存在于集合     | 因为底层数组有序，査找可以通过二分査找 法来进行，所以复杂度为O(logN)  
 intsetRandom   | 从整数集合中随机返回一个元素   | O(1)                                      
 intsetGet      | 取出底层数组在给定索引上的元素  | O(1)                                      
 intsetLen      | 返回整数集合包含的元素个数    | O(1)                                      
 intsetBlobLen  | 返回整数集合占用的内存字节数   | O(1)                                      

<a id="markdown-51-重点回顾" name="51-重点回顾"></a>
## 5.1. 重点回顾
  
  * 整数集合是集合键的底层实现之一
  * 整数集合的底层实现为数组，这个数组以有序、无重复的方式保存集合元素，在有需要时，程序会根据新添加元素的类型，改变这个数组的类型。
  * 升级操作为整数集合带来了操作上的灵活性，并且尽可能地节约了内存。
  * 整数集合只支持升级操作，不支持降级操作


<a id="markdown-6-p59-压缩列表" name="6-p59-压缩列表"></a>
# 6. p59-压缩列表

<a id="markdown-61-api" name="61-api"></a>
## 6.1. API
函数|作用|时间复杂度
-|-|-
 ziplistNew          | 创建一个新的压缩列表                           | O(1)                                                        
 ziplistPush         | 创建一个包含给定值的新节点，并将这个新节点添加到压缩列表的表头或者表尾  | 平均O(N),最坏O(N2)                                              
 ziplistlnsert       | 将包含给定值的新节点插人到给定节点之后                  | 平均O(N),最坏O(N2)                                              
 ziplistlndex        | 返回压缩列表给定索引上的节点                       | O(N)                                                        
 ziplistFind         | 在压缩列表中查找并返回包含了给定值的节点                 | 因为节点的值可能是一个字节数组，所以检查节点值和给定值是否相同的复杂度为O(N),而查找整个列表的复杂度为O(N2)  
 ziplistNext         | 返回给定节点的下一个节点                         | O(1)                                                        
 ziplistPrev         | 返回给定节点的前一个节点                         | O(1)                                                        
 ziplistGet          | 获取给定节点所保存的值                          | O(1)                                                        
 ziplistDelete       | 从压缩列表中删除给定的节点                        | 平均O(N),最坏O(N2)                                              
 ziplistDeleteRange  | 删除压缩列表在给定索引上的连续多个节点                  | 平均O(N),最坏O(N2)                                              
 ziplistBlobLen      | 返回压缩列表目前占用的内存字节数                     | O(1)                                                        
 ziplistLen          | 返回压缩列表目前包含的节点数量                      | 节点数量小于65535时为O(1),大于65535时为O(N)                             

<a id="markdown-62-重点回顾" name="62-重点回顾"></a>
## 6.2. 重点回顾

  * 压缩列表是一种为节约内存而开发的顺序型数据结构。
  * 压缩列表被用作列表键和哈希键的底层实现之一。
  * 压缩列表可以包含多个节点，每个节点可以保存一个字节数组或者整数值。
  * 添加新节点到压缩列表，或者从压缩列表中删除节点，可能会引发连锁更新操作，但这种操作出现的几率并不高。

<a id="markdown-7-p60-对象" name="7-p60-对象"></a>
# 7. p60-对象
在前面的数个章节里，我们陆续介绍了Redis 用到的所有主要数据结构，比如**简单动态
字符串（SDS )、双端链表、字典、压缩列表、整数集合**等等。

Redis 并没有直接使用这些数据结构来实现键值对数据库，**而是基于这些数据结构创建
了一个对象系统，这个系统包含字符串对象、列表对象、哈希对象、集合对象和有序集合对
象这五种类型的对象**，每种对象都用到了至少一种我们前面所介绍的数据结构。

通过这五种不同类型的对象， Redis 可以在执行命令之前， 根据对象的类型来判断一个
对象是否可以执行给定的命令。使用对象的另一个好处是，我们可以针对不同的使用场景，
为对象设置多种不同的数据结构实现，从而优化对象在不同场景下的使用效率。

除此之外，**Redis 的对象系统还实现了基于引用计数技术的内存回收机制，当程序不再
使用某个对象的时候， 这个对象所占用的内存就会被自动释放**；另外，Redis 还通过引用计
数技术实现了对象共享机制，这一机制可以在适当的条件下，通过让多个数据库键共享同一
个对象来节约内存。

最后，Redis 的对象带有访问时间记录信息，该信息可以用于计算数据库键的空转时
长，在服务器启用了maxmemor y 功能的情况下，空转时长较大的那些键可能会优先被服
务器删除。

<a id="markdown-71-键和值都是对象" name="71-键和值都是对象"></a>
## 7.1. 键和值都是对象

Redis 使用对象来表示数据库中的键和值，每次当我们在Redis 的数据库中新创建一个
键值对时，**我们至少会创建两个对象，一个对象用作键值对的键（ 键对象）， 另一个对象用
作键值对的值（ 值对象)。**

举个例子，以下见r 命令在数据库中创建了一个新的键值对，其中键值对的键是一个
包含了字符串值"msg" 的对象，而键值对的值则是一个包含了字符串值"hello world"
的对象：

```
SET msg "hello world"
```

```
typedef struct redisObject {
    // 类型
    unsigned type:4;
    
    // 编码
    unsigned encoding:4;
    
    // 指向底层实现数据结构的指针
    void *ptr;
   
   // ...
} robj;
```

<a id="markdown-72-对象的类型" name="72-对象的类型"></a>
## 7.2. 对象的类型

类型常量|对象的名称
-|-
REDIS_STRING|字符串对象
REDIS_LIST|列表对象
REDIS_HASH|哈希对象
REDIS_SET|集合对象
REDIS_ZSET|有序集合对象


<a id="markdown-73-不同类型值对象的type命令输出" name="73-不同类型值对象的type命令输出"></a>
## 7.3. 不同类型值对象的TYPE命令输出

对象|对象type属性的值|TYPE命令的输出
-|-|-
字符串对象|REDIS_STRING|"string"
列表对象|REDIS_LIST|"list"
哈希对象|REDIS_HASH|"hash"
集合对象|REDIS_SET|"set"
有序集合对象|REDIS_ZSET|"zset"


<a id="markdown-74-重点回顾" name="74-重点回顾"></a>
## 7.4. 重点回顾
  * Redis数据库中的每个键值对的键和值都是一个对象
  * Redis共有**字符串、列表、哈希、集合、有序集合**五种类型的对象，每种类型的对象至少都有两种或以上的编码方式，不同的编码可以在不同的使用场景上优化对象的使用效率。
  * 服务器在执行某些命令之前，会先检査给定键的类型能否执行指定的命令，而检查一个键的类型就是检查键的值对象的类型。
  * Redis的对象系统带有引用计数实现的内存回收机制，当一个对象不再被使用时，该
对象所占用的内存就会被自动释放。
  * Redis会共享值为0 到9999 的字符串对象。
  * 对象会记录自己的最后一次被访问的时间，这个时间可以用于计算对象的空转时间。

<a id="markdown-8-p90-单机数据库的实现" name="8-p90-单机数据库的实现"></a>
# 8. p90-单机数据库的实现

```
struct redisServer {
    // 一个数组,保存着服务器中的所有数据库
    redisDb *db;
};
```

在初始化服务器时,程序会根据服务器状态的dbnum属性来决定创建多少个数据库:

```
struct redisServer {
   // 服务器的数据库数量
  int dbnum;
};
```

dbnum属性的值由服务器配置的database选项决定，默认情况下，该选项的值为16,所以Redis服务器默认会创建16个数据库.

<a id="markdown-81-切换数据库" name="81-切换数据库"></a>
## 8.1. 切换数据库

```
SELECT 2
```

记录客户端当前的目标数据库
```

typedef struct redisClient {
    // 记录客户端当前正在使用的数据库
    redisDb *db;
} redisClient;
```

通过修改redisClient.db 指针，让它指向服务器中的不同数据库，从而实现切换目
标数据库的功能—SELECT—这就是命令的实现原理。


<a id="markdown-9-p98-读写键空间时的维护操作" name="9-p98-读写键空间时的维护操作"></a>
# 9. p98-读写键空间时的维护操作

当使用Redis 命令对数据库进行读写时，服务器不仅会对键空间执行指定的读写操作，还会执行一些额外的维护操作，其中包括：

  * 在读取一个键之后（读操作和写操作都要对键进行读取），服务器会根据键是否存在来更新服务器的键空间命中（hit)次数或键空间不命中（miss)次数，这两个值可以在命令的keyspace_hits属性和keyspace_misses属性中査看。
  * 在读取一个键之后，服务器会更新键的LRU(最后一次使用）时间，这个值可以用于计算键的闲置时间，使用OBJECTidletime<key>命令可以査看键key的闲置时间。
  * 如果服务器在读取一个键时发现该键已经过期，那么服务器会先删除这个过期键,然后才执行余下的其他操作，本章稍后对过期键的讨论会详细说明这一点。
  * 如果有客户端使用命令监视了某个键，那么服务器在对被监视的键进行修改之后， 会将这个键标记为脏（dirty ), 从而让事务程序注意到这个键已经被修改
  * 服务器每次修改一个键之后，都会对脏（dirty ) 键计数器的值增1， 这个计数器会触发服务器的持久化以及复制操作
  * 如果服务器开启了数据库通知功能，那么在对键进行修改之后，服务器将按配置发送相应的数据库通知，本章稍后讨论数据库通知功能的实现时会详细说明这一点。


<a id="markdown-10-p99-设置键的生存时间或过期时间" name="10-p99-设置键的生存时间或过期时间"></a>
# 10. p99-设置键的生存时间或过期时间
通过EXPIRE命令或者PEXPIRE命令，客户端可以以秒或者毫秒精度为数据库中的某
个键设置生存时间（TimeToLive,TTL)，在经过指定的秒数或者毫秒数之后，服务器就会
自动删除生存时间为0的键：
```
SET key value

EXPIRE key 5

// 5秒之后查询不到了
```

<a id="markdown-101-设置过期时间" name="101-设置过期时间"></a>
## 10.1. 设置过期时间

  * EXPIRE <key> <ttl> 命令用于将键key的生存时间设置为ttl秒
  * PEXPIRE <key> <ttl> 命令用于将键key的生存时间设置为ttl毫秒
  * EXPIREAT <key> <timestamp> 命令用于将键key的过期时间设置为timestamp所指定的秒数时间戳
  * PEXPIREAT <key> <timestamp> 命令用于将键key的过期时间设置为timestamp所指定的毫秒数时间戳

最终,EXPIRE,PEXPIRE和EXPIREAT三个命令都会转换成PEXPIREAT命令来执行.


<a id="markdown-102-保存过期时间" name="102-保存过期时间"></a>
## 10.2. 保存过期时间
redisDb结构的expires字典保存了数据库中所有键的过期时间,我们称这个字典为过期字典:

  * 过期字典的键是一个指针，这个指针指向键空间中的某个键对象（也即是某个数据库键）。
  * 过期字典的值是一个long long 类型的整数，这个整数保存了键所指向的数据库键的过期时间一个毫秒精度的UNIX 时间戳。

<a id="markdown-103-过期间删除策略" name="103-过期间删除策略"></a>
## 10.3. 过期间删除策略

  * 定时删除: 在设置键的过期时间的同时,创建一个定时器(timer),让定时器在键的过期时间来临时,立即执行对键的删除操作
  * 惰性删除: 放任键过期不管,但是每次从键空间中获取键时,都检查取得键是否过期,如果过期的话,就删除该键,如果没有过期,就返回该键
  * 定期删除: 每隔一段时间,程序就对数据库进行一次检查,删除里面的过期键.至于要删除多少过期键,以及要检查多少个数据库,则由算法决定.

在这三种策略中,第一种和第三种为主动删除策略,则第二种则为被动删除策略.

<a id="markdown-104-定时删除和惰性删除的缺点" name="104-定时删除和惰性删除的缺点"></a>
## 10.4. 定时删除和惰性删除的缺点

  * 定时删除占用太多CPU 时间，影响服务器的响应时间和吞吐量。
  * 惰性删除浪费太多内存，有内存泄漏的危险。

<a id="markdown-105-定期删除" name="105-定期删除"></a>
## 10.5. 定期删除

  * 定期删除策略每隔一段时间执行一次删除过期键操作，并通过限制删除操作执行的时长和频率来减少删除操作对CPU 时间的影响。
  * 除此之外，通过定期删除过期键，定期删除策略有效地减少了因为过期键而带来的内存浪费。

难点  

  * 如果删除操作执行得太频繁，或者执行的时间太长，定期删除策略就会退化成定时删除策略，以至于将CPU 时间过多地消耗在删除过期键上面。
  * 如果删除操作执行得太少， 或者执行的时间太短，定期删除策略又会和惰性删除策略一样，出现浪费内存的情况。


<a id="markdown-11-p137-rdb持久化" name="11-p137-rdb持久化"></a>
# 11. p137-RDB持久化

<a id="markdown-111-重点回顾" name="111-重点回顾"></a>
## 11.1. 重点回顾

  * RDB 文件用于保存和还原Redis 服务器所有数据库中的所有键值对数据。
  * SAVE命令由服务器进程直接执行保存操作，所以该命令会阻塞服务器。
  * BGSAVE令由子进程执行保存操作,所以该命令不会阻塞服务器
  * 服务器状态中会保存所有用save选项设置的保存条件,当任意一个保存条件被满足时,服务器会自动执行BGSAVE命令
  * RDB文件是一个经过压缩的二进制文件,由多个部分组成
  * 对于不同类型的键值对，RDB 文件会使用不同的方式来保存它们。


<a id="markdown-12-p138-aof持久化" name="12-p138-aof持久化"></a>
# 12. p138-AOF持久化

```
SADD fruits "apple" "banana" "cherry"
```

RDB持久化保存数据库状态的方法是将msg,fruits,numbers三个键的键值对保存到RDB文件中,而AOF持久化保存数据库状态的方法则是将服务器执行的SET,SADD,RPUSH三个命令保存到AOF文件中.

被写入AOF文件的所有命令都是以Redis的命令请求协议格式保存的,因为Redis的命令请求协议是纯文本格式,所以我们可以直接打开一个AOF文件,观察里面的内容.


<a id="markdown-121-不同appendfsync值产生不同的持久化行为" name="121-不同appendfsync值产生不同的持久化行为"></a>
## 12.1. 不同appendfsync值产生不同的持久化行为
appendfsync选项的值|flushAppendOnlyFile函数的行为
-|-
always|将aof_buf 缓冲区中的所有内容写入并同步到AOF 文件
everysec|将aof_buf缓冲区中的所有内容写入到AOF文件,如果上次同步AOF文件的时间距离现在超过一秒钟,那么再次对AOF文件进行同步,并且这个同步操作是由一个线程专门负责执行的
no|将aof_buf缓冲区中的所有内容写入到AOF文件,但并不对AOF文件进行同步,何时同步由操作系统来决定

appendfsync选项的默认值为everysec


<a id="markdown-122-aof持久化的效率和安全性" name="122-aof持久化的效率和安全性"></a>
## 12.2. AOF持久化的效率和安全性

当appendfsync 的值为always 时，服务器在每个事件循环都要将aof_buf 缓
冲区中的所有内容写入到AOF 文件，并且同步AOF 文件，所以always 的效率是
appendfsync 选项三个值当中最慢的一个，但从安全性来说，always 也是最安
全的， 因为即使出现故障停机，AOF 持久化也只会丢失一个事件循环中所产生的命
令数据。

当appendfsync 的值为everysec 时，服务器在每个事件循环都要将aof_buf
缓冲区中的所有内容写入到AOF 文件，并且每隔一秒就要在子线程中对AOF 文件
进行一次同步。从效率上来讲，everysec 模式足够快，并且就算出现故障停机，
数据库也只丢失一秒钟的命令数据。

当appendfsync 的值为no 时，服务器在每个事件循环都要将aof_buf 缓冲区
中的所有内容写入到AOF 文件，至于何时对AOF 文件进行同步， 则由操作系统控制
。因为处于n◦ 模式下的flushAppendOnlyFile 调用无须执行同步操作，所以
该模式下的AOF 文件写入速度总是最快的，不过因为这种模式会在系统缓存中积累
一段时间的写入数据，所以该模式的单次同步时长通常是三种模式中时间最长的。
从平摊操作的角度来看，no 模式和everysec 模式的效率类似，当出现故障停机
时，使用no 模式的服务器将丟失上次同步AOF 文件之后的所有写命令数据。

<a id="markdown-123-重点回顾" name="123-重点回顾"></a>
## 12.3. 重点回顾
  * AOF 文件通过保存所有修改数据库的写命令请求来记录服务器的数据库状态。
  * AOF 文件中的所有命令都以Redis 命令请求协议的格式保存。
  * 命令请求会先保存到AOF 缓冲区里面，之后再定期写入并同步到AOF 文件。
  * appendfsync 选项的不同值对AOF 持久化功能的安全性以及Redis 服务器的性能有很大的影响。
  * 服务器只要载人并重新执行保存在AOF 文件中的命令，就可以还原数据库本来的状态。
  * AOF 重写可以产生一个新的AOF 文件，这个新的AOF 文件和原有的AOF 文件所保存的数据库状态一样，但体积更小
  * AOF 重写是一个有歧义的名字，该功能是通过读取数据库中的键值对来实现的，程序无须对现有AOF 文件进行任何读入、分析或者写人操作。
  * 在执行BGREWRITEAOF命令时,Redis服务器会维护一个AOF重写缓冲区,该缓冲区会在子进程创建新AOF文件期间,记录服务器执行的所有写命令,当子进程完成创建新AOF文件的工作之后,服务器会重写缓冲区中的所有内容追加到新AOF文件的末尾,使得新旧两个AOF文件所保存的数据库状态一致.最后,服务器用心的AOF文件替换旧的AOF文件,以此来完成AOF文件重写操作.


<a id="markdown-13-p161-时间驱动重点回顾" name="13-p161-时间驱动重点回顾"></a>
# 13. p161-时间驱动重点回顾

  * Redis 服务器是一个事件驱动程序，服务器处理的事件分为时间事件和文件事件两类。
  * 文件事件处理器是基于Reactor 模式实现的网络通信程序。
  * 文件事件是对套接字操作的抽象：每次套接字变为可应答（acceptable )、可写(writable ) 或者可读（readab le ) 时，相应的文件事件就会产生。
  * 文件事件分为AE_READABLE 事件（读事件）和AE_WRITABLE 事件（写事件）两类。
  * 时间事件分为定时事件和周期性事件：定时事件只在指定的时间到达一次， 而周期性事件则每隔一段时间到达一次。
  * 服务器在一般情况下只执行serverCron 函数一个时间事件，并且这个事件是周期性事件。
  * 文件事件和时间事件之间是合作关系，服务器会轮流处理这两种事件，并且处理事件的过程中也不会进行抢占。
  * 时间事件的实际处理时间通常会比设定的到达时间晚一些。

<a id="markdown-14-p218-主从同步重点回顾" name="14-p218-主从同步重点回顾"></a>
# 14. p218-主从同步重点回顾

  * Redis 2.8 以前的复制功能不能高效地处理断线后重复制情况，但Redis 2.8 新添加的部分重同步功能可以解决这个问题。
  * 部分重同步通过复制偏移量、复制积压缓冲区、服务器运行ID 三个部分来实现
  * 在复制操作刚开始的时候， 从服务器会成为主服务器的客户端，并通过向主服务器发送命令请求来执行复制步骤，而在复制操作的后期，主从服务器会互相成为对方的客户端。
  * 主服务器通过向从服务器传播命令来更新从服务器的状态，保持主从服务器一致，而从服务器则通过向主服务器发送命令来进行心跳检测，以及命令丢失检测。 


<a id="markdown-15-p288-集群重点回顾" name="15-p288-集群重点回顾"></a>
# 15. p288-集群重点回顾

  * 节点通过握手来将其他节点添加到自己所处的集群当中。
  * 集群中的16384 个槽可以分别指派给集群中的各个节点，每个节点都会记录哪些槽指派给了自己， 而哪些槽又被指派给了其他节点。
  * 节点在接到一个命令请求时，会先检查这个命令请求要处理的键所在的槽是否由自己负责，如果不是的话，节点将向客户端返回一个MOVED 错误，MOVED 错误携带的信息可以指引客户端转向至正在负责相关槽的节点
  * 对Redis集群的重新分片工作是由redis-trib 负责执行的，重新分片的关键是将属于某个槽的所有键值对从一个节点转移至另一个节点。
  * 如果节点A 正在迁移槽i至节点B, 那么当节点A 没能在自己的数据库中找到命令指定的数据库键时，节点A 会向客户端返回一个ASK 错误，指引客户端到节点B 继续查找指定的数据库键。
  * MOVED 错误表示槽的负责权已经从一个节点转移到了另一个节点，而ASK 错误只是两个节点在迁移槽的过程中使用的一种临时措施。
  * 集群里的从节点用于复制主节点，并在主节点下线时，代替主节点继续处理命令请求
  * 集群中的节点通过发送和接收消息来进行通信，常见的消息包括MEET、PING、PONG、PUBLISH、FAIL 五种。


<a id="markdown-16--redis的acid" name="16--redis的acid"></a>
# 16. -redis的ACID

<a id="markdown-161-原子性atomicity" name="161-原子性atomicity"></a>
## 16.1. 原子性(Atomicity)
对于Redis 的事务功能来说，事务队列中的命令要么就全部都执行，要么就一个都不执
行，因此，Redis 的事务是具有原子性的。

```
MULTI
SET msg "hello"
GET msg
EXEC
```

```
OK
"hello"
```
Redis 的事务和传统的关系型数据库事务的最大区别在于，Redis 不支持事务回滚机制
(rollback), 即使事务队列中的某个命令在执行期间出现了错误，整个事务也会继续执行下
去，直到将事务队列中的所有命令都执行完毕为止。

Redis 的作者在事务功能的文档中解释说， 不支持事务回滚是因为这种复杂的功能和
Redis 追求简单高效的设计主旨不相符，并且他认为，Redis 事务的执行时错误通常都是编
程错误产生的，**这种错误通常只会出现在开发环境中，而很少会在实际的生产环境中出现，
所以他认为没有必要为Redis 开发事务回滚功能。
**
<a id="markdown-162-一致性consistency" name="162-一致性consistency"></a>
## 16.2. 一致性(Consistency)

  * 如果服务器运行在无持久化的内存模式下，那么重启之后的数据库将是空白的，因此数据总是一致的。
  * 如果服务器运行在RDB 模式下，那么在事务中途停机不会导致不一致性，因为服务器可以根据现有的RDB 文件来恢复数据，从而将数据库还原到一个一致的状态。如果找不到可供使用的RDB 文件，那么重启之后的数据库将是空白的，而空白数据库总是一致的
  * 如果服务器运行在AOF 模式下，那么在事务中途停机不会导致不一致性，因为服务器可以根据现有的AOF 文件来恢复数据，从而将数据库还原到一个一致的状态。如果找不到可供使用的AOF 文件，那么重启之后的数据库将是空白的，而空白数据库总是一致的。

<a id="markdown-163-隔离性isolation" name="163-隔离性isolation"></a>
## 16.3. 隔离性(Isolation)
事务的隔离性指的是，即使数据库中有多个事务并发地执行，各个事务之间也不会互相
影响，并且在并发状态下执行的事务和串行执行的事务产生的结果完全相同。
**因为Redis 使用单线程的方式来执行事务（以及事务队列中的命令）， 并且服务器保证，
在执行事务期间不会对事务进行中断，因此， Redis 的事务总是以串行的方式运行的，并且
事务也总是具有隔离性的。**

<a id="markdown-164-持久性durability" name="164-持久性durability"></a>
## 16.4. 持久性(Durability)
事务的耐久性指的是，当一个事务执行完毕时，执行这个事务所得的结果已经被保存到
永久性存储介质（比如硬盘）里面了，即使服务器在事务执行完毕之后停机，执行事务所得
的结果也不会丟失。

  * 当服务器在无持久化的内存模式下运作时，事务不具有耐久性：一旦服务器停机.包括事务数据在内的所有服务器数据都将丢失。
  * 当服务器在RDB 持久化模式下运作时，服务器只会在特定的保存条件被满足时，才会执行命令， 对数据库进行保存操作， 并且异步执行的不能保证事务数据被第一时间保存到硬盘里面，因此RDB 持久化模式下的事务也不具有耐久性。
  * 当服务器运行在AOF 持久化模式下，并且appendfsync 选项的值为always 时，程序总会在执行命令之后调用同步（sync) 函数，将命令数据真正地保存到硬盘里面，因此这种配置下的事务是具有耐久性的。
  * 当服务器运行在AOF 持久化模式下，并且appendfsync 选项的值为everysec时，程序会每秒同步一次命令数据到硬盘。因为停机可能会恰好发生在等待同步的那一秒钟之内，这可能会造成事务数据丢失，所以这种配置下的事务不具有耐久性
  * 当服务器运行在AOF 持久化模式下，并且appendfsync选项的值为no 时，程序会交由操作系统来决定何时将命令数据同步到硬盘。因为事务数据可能在等待同步的过程中丢失，所以这种配置下的事务不具有耐久性。


<a id="markdown-17-p385-慢查询日志重点回顾" name="17-p385-慢查询日志重点回顾"></a>
# 17. p385-慢查询日志重点回顾

  * Redis的慢查询日志功能用于记录执行时间超过指定时长的命令。
  * Redis服务器将所有的慢査询日志保存在服务器状态的slowlog 链表中，每个链表节点都包含一个slowlogEntry 结构，每个slowlogEntry 结构代表一条慢査询日志
  * 打印和删除慢查询日志可以通过遍历slowlog 链表来完成。
  * slowlog 链表的长度就是服务器所保存慢査询日志的数量。
  * 新的慢查询日志会被添加到slowlog 链表的表头，如果日志的数量超过slowlogmax-len 选项的值，那么多出来的日志会被删除。

