
<!-- TOC -->

- [1. 资源](#1-资源)
- [2. 基础概念](#2-基础概念)
- [3. SOA和微服务的对比](#3-soa和微服务的对比)
- [4. 业务数据独立](#4-业务数据独立)
- [5. 关于REST](#5-关于rest)
- [6. 部署方式的演化](#6-部署方式的演化)
- [7. 服务间通信机制小结](#7-服务间通信机制小结)
- [8. 微服务架构图](#8-微服务架构图)
    - [8.1. 一个java的技术选型](#81-一个java的技术选型)
        - [8.1.1. sprint boot相关插件(看下)](#811-sprint-boot相关插件看下)
        - [8.1.2. sprint boot 的应用场景](#812-sprint-boot-的应用场景)
- [9. 一个简单的流程](#9-一个简单的流程)
- [10. docker](#10-docker)
    - [10.1. docker 存储介质比较](#101-docker-存储介质比较)
    - [10.2. 不同发布环境的比较](#102-不同发布环境的比较)
- [11. 暂时没接触的技术关键字](#11-暂时没接触的技术关键字)

<!-- /TOC -->

# 1. 资源

* http://microservices.io/

# 2. 基础概念

系统架构设计描述了在应用系统内部,如何根据`业务,技术,组织,灵活性,可扩展性以及可维护性`等多种因素,将应用系统划分成不同的部分,并使这些部分彼此之间相互分工,相互协作,从而为用户提供某种特定价值的方式

随着`面向对象分析,设计模式,企业架构模式`等方法论的深入人心,从功能实现,代码组织的角度考虑,系统中不同职责的部分逐渐被划分到了如下三个层次:

* 表示层,聚焦数据显示和用户交互
* 业务逻辑层,聚焦业务逻辑处理
* 数据访问层,聚焦数据的存储与访问

虽然三层架构将系统在逻辑上分成三层,但它并不是物理上的分层,所有的代码最终还是运行在`同一个进程`中,对于这种`功能集中`,`代码中心化`,一个发布包,部署后运行在同一个进程,我们通常称之为`单块架构应用`

随着业务的不断扩大,需求功能的持续增加,单块架构已经很难满足业务快速变化的需要,因为:


* 维护成本增加  
 团队越来越大,相应的沟通成本,管理成本,人员协调成本必然会显著增加,譬如,使用java编写的中型应用而言,当代码量为`几万行`时,可能只需要`几人`左右的团队维护,当代码量上升到`几十万行`级别时,可能需要`几十人甚至是上百人`的团队.随着代码量的增加,在开发人员对全局功能缺乏深度理解的情况下,修复一个缺陷,还有可能引入其他缺陷
* 持续交付周期长  
 代码越来越复杂,构建和部署时间也会相应增加.
* 新人培养周期长  
 随着应用程序的功能越来越多,代码变得越来越复杂,对于新加入团队的成员而言,了解行业背景,熟悉应用程序业务,配置本地开发环境这些看似简单的任务,将会话费越来越长的时间
* 技术选型成本高  
 传统的单块架构系统倾向采用统一的技术平台或方案来解决问题,每个团队成员都必须使用相同的开发语言,持久化存储及消息系统,而且要使用类似的工具.随着应用程序的复杂性逐渐增加以及功能越来越多,如果团队希望尝试引入新的框架,技术,或者对现有技术栈升级,通常会面临不小的问题
* 可扩展性差  
 如果扩展要求紧急,`垂直扩展(Vertical Scaling或Scale-up)`可能是最容易的,如果舍得砸钱上IBM的服务器,Oracle的数据库或者来自EMC的存储设备,不用改变一行代码,整个世界都会变好的.
 与此相对,`水平扩展(Horizontal Scaling或Scale-out)`通常的做法是建立一个集群,通过在集群中不断添加新节点,然后借助前段的负载均衡器,将用户的请求按照某种算法,譬如`轮转法,散列法或者最小连接法`等合理地将请求分配到不同的节点上.对于单块架构而言,由于所有程序代码都运行在服务器上的同一个进程中,会导致应用程序的水平扩展成本非常高.
* 构建全功能团队难  
 随着应用程序的功能越来越多,代码变的越来越复杂,其应用程序的复杂结构也会逐渐地映射到研发团队的结构上.

互联网产品的特点:
* 创新成本低
* 需求变化快
* 用户群体庞大

随着市场变化加快,用户需求变化加快,用户访问量增加,单块架构应用的维护成本,人员培养成本,缺陷修复成本,技术架构演进的成本以及系统扩展成本等都在相应增加,`因此单块架构曾经的优势已逐渐无法适应互联网时代的快速变化,面临着越来越多的挑战.`

微服务架构是一种架构模式,它提倡将单一应用程序划分成一组小服务,服务之间互相协调,互相配合,为用户提供最终价值.每个服务运行在其独立的进程中,`服务与服务之间采用轻量级的通信机制互相沟通(通常是基于HTTP的RESTful API)`每个服务都围绕其具体业务进行构建,并且能够被独立地部署到生产环境,类生产环境.另外,应尽量避免统一的,集中式的服务管理机制,对具体的一个服务而言,应根据业务上下文,选择合适的语言,工具对其进行构建.

# 3. SOA和微服务的对比

自从Martin Fowler在2014年提出了`Micro Service(微服务)`的概念后,业界就卷起了一股关于微服务的热潮,大家谈论多年的`SOA(Service-Oriented Architecture,面向服务的架构)`,终于有了新的解决方案,人们不再需要笨重的`ESB(Enterprise Service Bus,企业服务总线)`,恰逢Docker技术逐渐普及,一个崭新的轻量级SOA架构`MSA(Micro Service Architecture,微服务架构)`伴随着Docker容器技术正向我们携手走来


SOA实现|微服务架构实现
-|-
企业级,自顶向下开展实施|团队级,自底向上开展实施
服务由多个子系统组成,粒度大|一个系统被拆分成多个服务,粒度细
企业服务总线,集中式的服务架构|无集中式总线,松散的服务架构
集成方式复杂(ESB/WS/SOAP)|`集成方式简单(HTTP/REST/JSON)`
单块架构系统,相互依赖,部署复杂|服务能独立部署

![](http://ouxarji35.bkt.clouddn.com/snipaste_20171103_164858.png)


# 4. 业务数据独立

传统的单块应用架构,倾向于采用统一的数据平台来存储所有的数据,随着业务的快速发展,需求的不断变化,`一方面数据变得越来越复杂,难以管理`,另一方面,随着应用系统的业务逻辑不断更新和发展,数据库不仅承担着数据存储的租用,`还承担着不同系统之间的集成作用`

传统的数据库大多是关系型数据库,存储的数据都是以结构化信息为主,随着互联网的发展,`数据的结构不具有确定性,结构发生的频率非常快`,对于如何与有效的维护业务数据,也成了一个难题,相应维护的成本也会越来越高

微服务架构对于处理业务数据的优势:
* 能够随着业务的发展,提供业务数据接口集成,而`不是以数据库的方式同其他服务集成`
* 能够随着业务的发展,选择更适合的工具管理或者迁移业务理数据

根据不同的业务需求选择不同的数据库:
* 产品数据的种类繁多,更新比较频繁,可以使用`MongoDB这种文档数据库`
* 用户访问系统时产生的会话信息,则可以使用`Redis等键值系统`进行存储
* 报表数据的结构变化不大,而且要求数据的高一致性,则可以使用关系型数据库

![](http://ouxarji35.bkt.clouddn.com/snipaste_20171103_212748.png)

# 5. 关于REST

表述行状态转移(Representational State Transfer,简称REST)是一种针对分布式应用系统设计和开发的方式,能有效降低系统的复杂性,提高可扩展性

同传统的`SOAP或者XML-RPC`,`REST`是一种更简洁和轻量级的架构风格,已经有越来越多的Web服务开始采用REST风格设计和实现相关系统.`注意REST是设计风格而不是标准.`REST通常使用`HTTP,URL和XML以及JSON`这些现有的广泛流行的协议和标准

# 6. 部署方式的演化
![](http://ouxarji35.bkt.clouddn.com/snipaste_20171104_164151.png)


* 手动部署  
 使用ssh工具,登录到目标机,下载需要部署的包,然后复制到指定位置,最后重启服务(效率低,人为出错的概率大)
* 脚本部署  
 使用shel脚本将这些下载,复制,重启等过程逐渐实现自动化,大幅提升了效率
* 基础设施部署自动化  
 使用Chef,Puppet,Ansible等工具,完成软件的安装和配置,以及应用或者服务的部署
* 应用部署自动化  
 映像部署(AWS AMI) + 容器部署(Docker)


# 7. 服务间通信机制小结
![](http://ouxarji35.bkt.clouddn.com/snipaste_20171104_165912.png)


# 8. 微服务架构图

![](http://ouxarji35.bkt.clouddn.com/snipaste_20171105_205644.png)

当`service`启动时,会自动将其信息注册到`Service Registry(服务注册表中)`,比如:每个服务的IP与端口,当WebUI上发出请求时,该请求会发送到`Service GateWay(服务网关)`中,`Service Gateway`读取请求数据,并从`Service Registry`中获取对应`Service`的信息(IP与端口),最后`Service Gateway`主动去调用下面对应的Service

## 8.1. 一个java的技术选型
![](http://ouxarji35.bkt.clouddn.com/snipaste_20171105_210648.png)

* 1.使用Jenkins部署服务
* 2.使用Spring Boot开发服务(`提供REST API`)
* 3.使用Docker封装服务
* 4.使用ZooKeeper注册服务
* 5.使用Node.js调用服务

除了上面的技术选型之外,实际上还有其他可选择的方案,比如Netflix公司开源的`微服务技术栈`
* http://netflix.github.io/
* http://projects.spring.io/spring-cloud/
* http://wildfly-swarm.io/
* https://ee.kumuluz.com/


### 8.1.1. sprint boot相关插件(看下)

官方提供了大量插件,涉及的面非常广,包括Web,SQL,NoSQL,安全,验证,缓存,消息队列,分布式事务,模板引擎,工作流,还提供了Cloud,Social,Ops方面的支持

* SQL API - JDBC,JPA,JOOQ等
* 关系型数据库 - MySQL,PostgreSQL等
* 内存数据库 - H2,HSQLDB,Derby等
* NoSQL数据库 - Redis,MongoDB,Cassandra等
* 消息队列 - RabbitMQ, Artemis,HornetQ等
* 分布式事物 - Atomikos,Bitronix等
* 模板引擎 - Velocity, Freemarker,Mustache等
* https://start.spring.io/ (自动生成代码)


### 8.1.2. sprint boot 的应用场景

* 传统Web MVC架构
* 前后端分离架构
* 微服务架构

# 9. 一个简单的流程

开发,测试,部署,运维,监控,流水线

* 代码测试与静态检查
* 构建docker镜像
* 部署docker镜像(AWS EC2/Cloudformation)
* 持续集成与交付(持续集成工具Snap-CI,自动检测代码提交事件,运行测试,静态检查,打包及部署)
* 监控与警告(Nagios)
* 日志聚合(Splunk)
* 功能迭代


# 10. docker

## 10.1. docker 存储介质比较

![](http://ouxarji35.bkt.clouddn.com/snipaste_20171104_160652.png)


## 10.2. 不同发布环境的比较

![](http://ouxarji35.bkt.clouddn.com/snipaste_20171104_162042.png)

# 11. 暂时没接触的技术关键字

* AWS Web Service 提供的CloudFormation
* Netflix提供的Asgard
* github + Snap-CI + dockerhub 构建持续交付流水线
* Bamboo / Jenkins / Travis-CI / CircleCI
* 日志聚合 Splunk 和 LogStash
* 监控 Ganglia / Zabbix / NewRelic / Nagios
* 消息队列ActiveMQ / RabbitMQ
