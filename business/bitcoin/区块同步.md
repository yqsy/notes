---
title: 区块同步
date: 2018-02-01 13:29:12
categories: [business, bitcoin]
---

<!-- TOC -->

- [1. 区块同步](#1-区块同步)
- [2. 最长链](#2-最长链)

<!-- /TOC -->


<a id="markdown-1-区块同步" name="1-区块同步"></a>
# 1. 区块同步

TODO


<a id="markdown-2-最长链" name="2-最长链"></a>
# 2. 最长链

从网络同步到区块时的CBlockIndex::nChainWork (工作量累积字段的更新)

GetBlockProof 函数是计算nBits得到一个解时需要计算的hash数量.

函数本身经过了以下几个思考:

`版本1:`
```
2**256 / (bnTarget+1)
```

`版本2:`
```
((2**256 - bnTarget - 1) / (bnTarget+1)) + 1
```

`版本3:`
```
~bnTarget / (bnTarget+1) + 1
```

`为什么是bnTarget+1?`

假设target是0xffff,对应的十进制是65535,而[0,65535]区间的数字个数是65536,所以要bnTarget+1,表示准确的数量

`为什么要把在版本2把分母改成(2**256 - bnTarget - 1) ?`

因为比特币的256位数字使用arith_uint256存放,其取值范围是[0, 2**256-1], 2**256越界了.所以减去一份分子,然后在除法的后面加上1. 来使得不越界.

`为什么要调整到版本3  ~bnTarget / (bnTarget+1) + 1 ?`

(2**256 - bnTarget - 1) 表示32字节数字的所有可能减去target的可能部分,那么就是在32字节内对target部分的取反,得到另一可能部分

`在CBlockIndex中这个数字是累加的会越界吗?`  
不会. 因为 ```2 **256 = 10 ** 77 ```(大约), 每次都是累计小于target的计算次数也是加不到那么多的.高度551,687时, 需要```2.9 * 10**22 ```次hash能找到小于target的范围内的数字. 而个工作量的累加还有 ```10 ** 55```来计数.

`计算方法:`
```python
import math
math.log(2**256, 10)
```


GetBlockProofEquivalentTime

