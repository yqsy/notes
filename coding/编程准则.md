---
title: 编程准则
date: 2017-11-25 20:24:00
categories: [coding]
---

<!-- TOC -->

- [1. 不允许重复](#1-不允许重复)
- [2. 模块正交性](#2-模块正交性)
- [3. 避免全局变量](#3-避免全局变量)
- [4. 函数的可读性](#4-函数的可读性)
- [5. 让断言开着](#5-让断言开着)
- [6. 嵌套的分配](#6-嵌套的分配)
- [7. 函数的得墨忒耳法则](#7-函数的得墨忒耳法则)
- [8. 细节会弄乱整洁的代码](#8-细节会弄乱整洁的代码)
- [9. Configure,Dont't Integrate](#9-configuredontt-integrate)
- [10. Put Abstractions in Code,Details in Metadata](#10-put-abstractions-in-codedetails-in-metadata)
- [11. 时间耦合](#11-时间耦合)
- [12. 快速的负载均衡手段](#12-快速的负载均衡手段)
- [13. 总是为并发进行设计](#13-总是为并发进行设计)
- [14. 分而治之](#14-分而治之)
- [15. 什么是完美](#15-什么是完美)
- [16. 工作流](#16-工作流)
- [17. 代码是写给人看的](#17-代码是写给人看的)
- [18. 代码尽量少](#18-代码尽量少)
- [19. 让程序员做无用功的语言才是烂语言](#19-让程序员做无用功的语言才是烂语言)
- [20. 从上至下驱动法](#20-从上至下驱动法)
- [21. 文字约束是无效的](#21-文字约束是无效的)
- [22. do语句](#22-do语句)

<!-- /TOC -->


以下内容摘自书本<程序员修炼之道:从小工到专家>,...(忘记了),或由自己感悟所得


<a id="markdown-1-不允许重复" name="1-不允许重复"></a>
# 1. 不允许重复
系统中的每一个知识都必须具有单一,无歧义,权威的表示. 应该使用一个数据抽象, 根据这个抽象用脚本生成不同的实例 

<a id="markdown-2-模块正交性" name="2-模块正交性"></a>
# 2. 模块正交性
模块与模块之间不能产生依赖,而是用其接口进行相互协作. 这样对于每一个模块都可以写单元测试的代码了.

<a id="markdown-3-避免全局变量" name="3-避免全局变量"></a>
# 3. 避免全局变量
当变量的作用于变成了全局,其依赖性就不明确了,它到底是派什么用场,它在哪个模块被用到? 

<a id="markdown-4-函数的可读性" name="4-函数的可读性"></a>
# 4. 函数的可读性
业务代码应当可以如行云流水般的往下阅读,不存在任何一个字段的看不懂,不存在一个逻辑的看不懂(都可以迅速的找到相应的说明)

<a id="markdown-5-让断言开着" name="5-让断言开着"></a>
# 5. 让断言开着
把程序交付时关闭断言就好像是因为你曾经成功过,就不用保护网去走钢丝,那样做有极大的价值,但却难以获得人身保险.

<a id="markdown-6-嵌套的分配" name="6-嵌套的分配"></a>
# 6. 嵌套的分配
不管我们在使用的是何种资源 -- 事务,内存,文件,线程,窗口, 基本模式-- 无论是谁分配的资源,它都应该解除该资源的分配.

<a id="markdown-7-函数的得墨忒耳法则" name="7-函数的得墨忒耳法则"></a>
# 7. 函数的得墨忒耳法则
给定程序之中的模块之间的耦合减少至最少 
就是一个类只使用另一个直接能够接触到的类的函数接口. 
"作为总承包人,模块必须直接委托并管理全部子承包人,而不牵涉模块的客户",意味要写很多包装的方法,但是为了提高可读性,非常值得.

<a id="markdown-8-细节会弄乱整洁的代码" name="8-细节会弄乱整洁的代码"></a>
# 8. 细节会弄乱整洁的代码
把细节赶出代码, 你一份业务代码,到处都是为了适应底层的接口而写的细节, 那就是在找死.


<a id="markdown-9-configuredontt-integrate" name="9-configuredontt-integrate"></a>
# 9. Configure,Dont't Integrate
 要配置不要集成,元数据,windows下ini,系统注册表,Java Property

<a id="markdown-10-put-abstractions-in-codedetails-in-metadata" name="10-put-abstractions-in-codedetails-in-metadata"></a>
# 10. Put Abstractions in Code,Details in Metadata
将抽象放进代码, 细节放进元数据 
建议以纯文本方式表示配置元数据 
考虑一下你的应用的使用方式:如果它是长期运行的服务器进程,你可以提供某种途径,在程序运行的过程中重新读取并应用元数据

<a id="markdown-11-时间耦合" name="11-时间耦合"></a>
# 11. 时间耦合
去掉基于时间的依赖: 工作流分析,架构,设计,部署

<a id="markdown-12-快速的负载均衡手段" name="12-快速的负载均衡手段"></a>
# 12. 快速的负载均衡手段
在多个消费者进程间进行快速而粗糙的负载平衡的一种途径:饥饿的消费者模型 hungry consumer

<a id="markdown-13-总是为并发进行设计" name="13-总是为并发进行设计"></a>
# 13. 总是为并发进行设计
总是为并发进行设计,例如 c 里面的 strtok违背了原则,使用这个函数就是在挖坑,. 
如果我们在设计的时候考虑到了并发,到时我们就更容易地满足可伸缩性或性能需求.

<a id="markdown-14-分而治之" name="14-分而治之"></a>
# 14. 分而治之
不要把程序写成一大块,而应该分而治之,每个模块都有其自身的责任

问题是,模块之间如何互相交互? (基于事件可以使对象之间的耦合减少到最少)

<a id="markdown-15-什么是完美" name="15-什么是完美"></a>
# 15. 什么是完美
完美，不是在没有什么需要增加，而是在没有什么需要去掉时达到的

<a id="markdown-16-工作流" name="16-工作流"></a>
# 16. 工作流
目标驱动，小里程碑，快速迭代；模块化，降耦合；重接口，轻实现；定期重构。

<a id="markdown-17-代码是写给人看的" name="17-代码是写给人看的"></a>
# 17. 代码是写给人看的
代码的写法应当使别人理解它的时间最小化 
程序是写出来给人看的，附带在机器上运行

<a id="markdown-18-代码尽量少" name="18-代码尽量少"></a>
# 18. 代码尽量少
一个操作所需要的代码越多，就越难发现bug

<a id="markdown-19-让程序员做无用功的语言才是烂语言" name="19-让程序员做无用功的语言才是烂语言"></a>
# 19. 让程序员做无用功的语言才是烂语言
让程序员做无用功的语言才称的上烂。 
浪费程序员的时间而不是计算机的时间才是真正的无效率

<a id="markdown-20-从上至下驱动法" name="20-从上至下驱动法"></a>
# 20. 从上至下驱动法
传统方式写代码时采用:边想,边写,出现情况A,插入情况A的代码,出现情况B,插入情况B的代码...导致代码不断冗余,到最后可读性下降到恶心的地步.

从上而下驱动法:在顶层思考出现的所有的状态,根据不同的状态走不通的逻辑

可以学习下有限状态机,行为树

<a id="markdown-21-文字约束是无效的" name="21-文字约束是无效的"></a>
# 21. 文字约束是无效的
例如修改代码A处,A处旁边的注释告诉你说,修改这里时要注意修改别的地方,这样的做法是不明智的(工作中碰到)


<a id="markdown-22-do语句" name="22-do语句"></a>
# 22. do语句
do语句是错误和困惑的来源，应该使while语句放前面 《c++程序设计语言》



