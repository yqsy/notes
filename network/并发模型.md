

<!-- TOC -->

- [1. 资料](#1-资料)
- [2. 简单概念](#2-简单概念)
- [3. 7个模型](#3-7个模型)
- [4. 线程与锁模型](#4-线程与锁模型)

<!-- /TOC -->


# 1. 资料

* <7周7并发模型>

# 2. 简单概念

并发编程概念最近才火起来，Erlang Haskell Go Scala Clojure对并发编程提供了良好的支持

* 并发:程序语言被设计成能够处理多个同时发生的事件(或者几乎同时)  
  并发程序执行通常是不确定的。随着事件时序的改变给出不同的结果
* 并行:通过将问题中的多个部分并行执行，来加速解决问题  
  并行程序是确定的。例如将数组分为两部分并把数组中的每个数都加倍

单核在位级和指令级两个层次上都能够并行的使用晶体管资源


* 位级(bit-level)并行  
  对于两个32位数的加法，8位计算机必须进行都次8位计算而32位计算机可以一步完成，即并行地处理32位数的4字节
* 指令级(instruction-level)并行  
  现代cpu的并行度很高，其中包括流水线，乱序执行和猜测执行等
* 数据级(data)并行  
  单指令多数据SIMD架构。可以并行地在大量数据上施加同一操作(图像处理)
* 任务级(task-level)并行  
  并行形式–多处理器，每个处理器都能访问整个内存。

当处理器个数逐渐增多，共享内存就会遭遇到性能瓶颈，此时，不得不转向分布式内存

# 3. 7个模型

* 线程与锁  
  很多并发软件开发的首选
* 函数式编程  
  消除了可变状态，从根本上是线程安全的，而且易于并行执行
* clojure之道  
  分离标识与状态:指令式编程和函数式编程的混搭方案
* actor  
  适用于共享内存模型和分布式内存模型，也适合解决地理分布式型问题，能提供强大的容错性
* csp  
  通信顺序进程(communicating seqential processes csp) 与actor模型很相似，两者都基于消息传递。不过csp模型侧重于传递信息的通道，而actor模型侧重于通道两端的实体
* 数据级并行 gpu  
  有限元分析，流体力学计算或其他的大量数字计算。
* lambda架构  
  综合了mapreduce和流式处理的特点，是一种可以处理多种大数据问题的架构

我觉得还有
* 非阻塞 eventloop  
  用贴近机器的方式去写代码

带着问题去了解并发模型:

* 这个模型适用于解决并发问题，并行问题，还是两者皆可？
* 这个模型适用于哪种并行架构？
* 这个模型是否有利于我们写出容错性强的代码，或用于解决分布式问题的代码？

# 4. 线程与锁模型

> 线程与锁模型就像一辆福特T型汽车，驾驶它可以达到目的地。但与新的技术相比，它显的原始且难以驾驭。

问题:
* 竞态条件 -> 加锁解决
* 死锁 -> 哲学家进餐. 解决方法是对多把锁进行编号,按照一个全局固定的顺序获取多把锁
* 内存可见性 -> 线程1 A初始化 B初始化  线程2 访问B 再访问A 就会有问题(会乱序,要加锁)
* 乱序 1. 编译器静态优化 2.jvm动态优化 3.硬件优化

规则:
* 对共享变量的所有访问都需要同步化
* 读线程和写线程都需要同步化
* 按照约定的全局顺序来获取多把锁
* 当持有锁时避免调用外星方法
* 持有锁的时间应尽可能短

同步方案:
* 互斥体
* 条件变量
* 原子量(lock-free non-blocking)

其他:
* 线程池
* 生产者消费者
* 避免竞争，cocurrenthashmap锁分段

优点:
* 线程与锁模型更接近于本质，近似对硬件工作方式的形式
* 正确使用，效率很高

缺点:
* 没有为并行提供直接的支持。
* 仅支持共享内存模型，如果要支持分布式内存模型，就需要寻求其他技术的帮助
* 死锁，例如哲学家进餐
* 乱序，假如用乱序执行的方式访问内存，并不意味乱序一定会发生，直到升级jvm或者使用不同的硬件时才会发生诡异的事情
* 可维护性差，问题不易马上被发现
